# Essential modules / Python environment
#
The "sys" module. It permits access to interpreter members.
>>> import sys
For example, we can see where do the interpreter looks for python packages through "path" module:
>>> sys.path
have access to command-line arguments,
>>> sys.argv
or access I/O channels (see stdout, stdin, stderr).

To get to know what is running (or loaded) on the current namespace, node can use the "dir()" function.
>>> dir()


# Command-line execution
#
By the end of a "foo.py" module, we can write statements for tests or just "higher level" interface for usage from command-line.
The statement
<verbatim>
if __name__ == "__main__":
 (É)
</verbatim>
will execute the code at "(É)" when "foo.py" is called like:
$ python foo.py


# Importing modules
#
Modules(or packages) loading is done with "import" statement or, if the package contents is known, one can use "from - import" line.
>>> import string
>>> from os import system

* Avoid using "from - import *". It looses readability mess with namespaces. If need/wantedone can always usean alias. For example:
>>> import numpy as np
or
>>> from scipy import ndimage as ndi


# Object-Oriented Programming
#
Object-Oriented Programming(OOP) 

 An object is a discrete bundle of data and functions, relating to a data structure and their particular procedures. Self-sufficient pieces of program - the _classes_ - are basically composed by a data structure (_members_) and associated functions, called _methods_. As said, OOP deals with the model of self-sufficient coding blocks that interact with each-other.
 An object-oriented program may thus be viewed as a collection of interacting objects, as opposed to the conventional model, in which a program is seen as a list of tasks to perform. In OOP, each object has their actions (or "methods") closely associated with their members. OOP data structures tend to 'carry their own operators around with them' (or at least "inherit" them from a similar object or class).
 The (OOP) technology focuses on data rather than processes. Different from functional (structured) programming that focuses on the function of a module and tends to consider data and behavior separately.
